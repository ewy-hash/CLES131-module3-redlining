---
title: "Module 3: Redlining"
format: pdf
editor: source
editor_options: 
  chunk_output_type: console
---

```{r}
#| warning: false
library(sf) # simple features for R
library(terra) # spatial data analysis
library(tidyterra) #tidyverse methods for terra objects
library(ggplot2)
```

### Use of GitHub

Link to your forked GH repository:
https://github.com/ewy-hash/CLES131-module3-redlining#

### Use of Quarto

Link to your .qmd file:
https://github.com/ewy-hash/CLES131-module3-redlining/blob/main/module3.qmd

# Ecological consequences of redlining

In August 2020, [Christopher Schell](https://cjschell.com/about) and collegues published a review in *Science* on ['The ecological and evolutionary consequences of systemic racism in urban environments'](https://science.sciencemag.org/content/early/2020/08/12/science.aay4497) showing how systematic racism and classism has significant impacts on ecological and evolutionary processes within urban environments. Here, we combine spatial data to reproduce and extend an analysis from the paper.

## The vector data

We will use a vector dataset of redlining maps from [Mapping Inequality](https://dsl.richmond.edu/panorama/redlining), a project led by [Robert K. Nelson](https://americanstudies.richmond.edu/faculty/rnelson2/).

### Q1 (1 point)

Click 'Explore the Maps' to look at some cities and neighborhoods you are familiar with. Who is the intended audience of this data science project, and how are the data used to communicate understanding, insight, and knowledge? Why is this effective?

I looked at the San Francisco area since that is near where I'm from. It seems like the intended audience could be citizens who want to glean a deeper understanding about the history of the areas they are from. As well, this is an important tool for education. The data communicates not just visually, but also gives context using the "context" tab and the "area descriptions" tab. In general, people tend to have an emotion connection to places they live near and/or are familiar with. By  highlighting the language used by the creators of the map, it evokes an emotional response in the viewer.

### Q2 (1 point)

Create a `data/` folder in the root of your project and create five subfolders labeled with the city names from Fig. 2 of Schell et al. 2020. Because the spatial files will be large, add `data/` to the .gitignore file. 

Then, go back to the home page of [Mapping Inequality](https://dsl.richmond.edu/panorama/redlining) and select 'Download the Data'. Use the search bar to select and download spatial data for each city. Move the geojson file into the associated data subfolder. 

Import the geojson file into your R environment with the `read_sf`()` function from sf. Check the structure of this object and see that it is a special type of data frame, allowing it to be manipulated with many of the functions you already know, including ggplot. 

Make a quick plot of your first city showing the "grade" in color using ggplot syntax and `geom_sf()`. Select a color scheme that better comports with redlining. 

```{r}
## need to already be in module 3 file
Baltimore <- read_sf("Data/Baltimore/geojson.json")
Minneapolis <- read_sf("Data/Minneapolis/geojson.json")
Birmingham <- read_sf("Data/Birmingham/geojson.json")
Phoenix <- read_sf("Data/Phoenix/geojson.json")
Indianapolis <- read_sf("Data/Indianapolis/geojson.json")


plot <- ggplot(data = Baltimore)+ 
  geom_sf(aes(fill = grade))+
  scale_fill_manual(values = unique(Baltimore$fill))
plot
```
}}
## The raster data

We will also be calculating NDVI from the European Space Agency's Sentinel-2 Mission, specifically bands B4 (red) and B8 (near infrared). There are multiple steps to importing the data, which itself takes a long time, so please get an early start.

 - Click "Explore Sentinel-2 data" on this [page](https://dataspace.copernicus.eu/data-collections/copernicus-sentinel-data/sentinel-2) and create an account to login
 - In the explorer, make sure Sentinel-2 L2A is selected (Level 2A, atmospheric correction applied)
 - Scroll and zoom to the city of choice
 - Use the polygon tool (upper right corner, hover over pentagon icon and select rectangle) to draw a bounding box. Adjust until the extent approximates those in Schell et al. 2020. Try selecting the "False color" layer to help diagnose features to include or exclude
 - Set a threshold for cloud cover and select a date that reasonably approximates peak greenness. You may have to test multiple options to locate it, and not all cities will have the same date
 - Once the displayed images looks satisfactory, click "Find products for current view"
 - Check the desired product and download. It will take a while because the files are large
 
The data will be packaged as a zipped SAFE file in your Downloads folder. You may need to investigate the properties of the file and click 'unblock' to give permission to open. Once unzipped, you will find:
 - The images are jpeg2000 files nested within the GRANULE and IMG_DATA subfolders
 - Multiple resolutions and bands are avalailable
 - Metadata is provided in `MTD_MSIL2A.xml`

For each city, copy the coarsest resolution files for the B04 and B08 bands along with associated metadata to `data/city_name/` within this project. 

## B04 is red and B08 is near infared, good for mapping imagery, both have resolution of 10 m

### Q3 (1 point)
Use the terra package and the `rast()` function to import the two bands, which are reported as digital numbers. Combine to calculate NDVI and display a quick plot of your first city. Since you have 5 cities to plot, how can you optimize these operations with a for loop? (Not necessary to actually do so.) 
Terra is for manipulating spacial data in the raster format.
could use a list of all the data 

```{r}
#red is red, NIR is near infared
REDbaltimore <- rast(x = "Data/Baltimore/T18SUJ_20230525T154941_B04.jp2")
NIRbaltimore <- rast(x = "Data/Baltimore/T18SUJ_20230525T154941_B08.jp2")
NDVIbaltimore <- (NIRbaltimore - REDbaltimore) / (NIRbaltimore + REDbaltimore)

ggplot()+
  geom_spatraster(data = NDVIbaltimore)

#ggplot()+
  # geom_spatraster(data = NIRbaltimore)

```
### Q4 (1 point)
Do the rasters and polygons share the same coordinate reference system? If not, project both into the same coordinate system and defend your choice. 

```{r}
# seems like they do share the coordiante system, as you can see from running the code below they both get placed onto the map using longitude and latitude coords


test <- ggplot(data = Baltimore)+
  geom_sf()+
  geom_spatraster(data = NIRbaltimore, alpha = 0.5)
test

```
### Q5 (1 points)
Overlay the projected vector file onto the projected NDVI for a single city using `tidyterra::geom_spatraster()` in addition to `geom_sf()`. Adjust the color scales and add a scale bar to approximate Fig. 2a of Schell et al. 2020. 

```{r}
# first am gonna figure out the spatraster data and how to color etc
#to check if they have same coord system EPSG value, not very helpful as NDVI has lots of values


crs(Baltimore)
crs(NDVIbaltimore)

#seems like they dont actually share the same CRS so have to transform

ext(NDVIbaltimore)
ext(Baltimore)

st_transform(x = NDVIbaltimore, crs = "EPSG:4326")
#need to change NDVIbaltimore to spsg 4326 which is what Baltimore has
#project from terra
#:: means it uses the function from that package
NDVIbaltimorePLOT <- terra::project(x = NDVIbaltimore, "EPSG:4326")

ggplot()+
  geom_spatraster(data = NDVIbaltimorePLOT)+
  scale_fill_gradient(low = "white", high = "forestgreen", name = "NDVI")+
  geom_sf(data = Baltimore, fill = NA, color = "black")+
  # scale_x_continuous(limits = c(76.800, 76.200))+
  # scale_y_continuous(limits)
  coord_sf(xlim = c(-76.800, -76.500), ylim = c(39.150, 39.450))

#this worked but dont want to have to put in limits each time
# also the raster data is showing everywhere when it should be showing only in the polygons.need to mask, to use mask( ) both need to be spatwhatever

ggplot()+
  geom_spatraster(data = NDVIbaltimorePLOT)+
  scale_fill_gradient(low = "white", high = "forestgreen", name = "NDVI")+
  geom_sf(data = Baltimore, fill = NA, color = "black")+
  # scale_x_continuous(limits = c(76.800, 76.200))+
  # scale_y_continuous(limits)
  coord_sf(xlim = c(-76.800, -76.500), ylim = c(39.150, 39.450))
  

#want to combine with 
plot <- ggplot(data = Baltimore)+ 
  geom_sf(aes(fill = grade))+
  scale_fill_manual(values = unique(Baltimore$fill))

#sooooo

ggplot()+
  #raster
  geom_spatraster(data = NDVIbaltimorePLOT)+
  scale_fill_gradient(low = "white", high = "forestgreen", name = "NDVI")+
  
  #polygons
  geom_sf(data = Baltimore, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-76.800, -76.500), ylim = c(39.150, 39.450))


  #now to mask, needs 2 spats, convert baltimore to spat??
#google says use ggnewscale to have multiple scales so i can have inside and inverse raster data
install.packages("ggnewscale")
library(ggnewscale)



asvect <- as_spatvector(Baltimore)
NDVI_inside <- mask(NDVIbaltimorePLOT,asvect)
NDVI_outside <- mask(NDVIbaltimorePLOT,asvect, inverse=TRUE)



baltimore_plot <- ggplot()+
  #BW raster
  geom_spatraster(data = NDVI_outside)+
  scale_fill_gradient(low="white", high = "grey", guide = "none")+

  #geom_spatraster(data = NDVIbaltimorePLOT)+
  #scale_fill_gradient(low= "white",high = "black")+
  #raster
  ggnewscale::new_scale_fill()+
  geom_spatraster(data = NDVI_inside)+
  scale_fill_gradient(low = "white", high = "forestgreen", na.value = NA, name = "NDVI")+
  
  #polygons
  geom_sf(data = Baltimore, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-76.770, -76.510), ylim = c(39.175, 39.410))+
  #title and save
  labs(title = "Map of Baltimore Redlining Grades Compared to \nSatellite NDVI Greenery Data")

baltimore_plot

ggsave(filename = "BaltimorePLOT.png", 
       path = "PLOTS/", 
       width = 6, 
       height = 6, 
       dpi = 600)

  

#color_grade_table<- as.data.frame(Baltimore)[c("grade", "fill")]
#color_grade_table<-unique(color_grade_table)

```
### Q6 (1 point)
Repeat the above for all 5 cities and add the city name. Explore the `cowplot` or `patchwork` packages to create a multi-panel figure.
```{r}
#reconfigured to work for each of the cities by just changing the file names and a few other things

####Baltimore####
RED <- rast(x = "Data/Baltimore/T18SUJ_20230525T154941_B04.jp2")
NIR <- rast(x = "Data/Baltimore/T18SUJ_20230525T154941_B08.jp2")
NDVI <- (NIR - RED) / (NIR + RED)


NDVIplot<- terra::project(x = NDVI, "EPSG:4326")
asvect <- as_spatvector(Baltimore)
NDVI_inside <- mask(NDVIplot,asvect)
NDVI_outside <- mask(NDVIplot,asvect, inverse=TRUE)



baltimore_plot <- ggplot()+
  #BW raster
  geom_spatraster(data = NDVI_outside)+
  scale_fill_gradient(low="white", high = "grey", guide = "none")+

  #geom_spatraster(data = NDVIbaltimorePLOT)+
  #scale_fill_gradient(low= "white",high = "black")+
  #raster
  ggnewscale::new_scale_fill()+
  geom_spatraster(data = NDVI_inside)+
  scale_fill_gradient(low = "white", high = "forestgreen", na.value = NA, name = "NDVI")+
  
  #polygons
  geom_sf(data = Baltimore, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-76.770, -76.510), ylim = c(39.175, 39.410))+
  #title and save
  labs(title = "Map of Baltimore Redlining Grades Compared to \nSatellite NDVI Greenery Data")

baltimore_plot

ggsave(filename = "BaltimorePLOT.png", 
       path = "PLOTS/", 
       width = 6, 
       height = 6, 
       dpi = 600)

```
```{r}
####Minneapolis####
RED <- rast(x = "Data/Minneapolis/T15TVK_20220603T170901_B04.jp2")
NIR <- rast(x = "Data/Minneapolis/T15TVK_20220603T170901_B08.jp2")
NDVI <- (NIR - RED) / (NIR + RED)

#had to check a few things
#ext(NDVIplot)
#ext(asvect)


NDVIplot<- terra::project(x = NDVI, "EPSG:4326")
asvect <- as_spatvector(Minneapolis)
NDVI_inside <- mask(NDVIplot,asvect)
NDVI_outside <- mask(NDVIplot,asvect, inverse=TRUE)

#ggplot()+
#  geom_spatraster(data = NDVI_inside)


minneapolis_plot <- ggplot()+
  #BW raster
  geom_spatraster(data = NDVI_outside)+
  scale_fill_gradient(low="white", high = "grey", guide = "none")+

  #geom_spatraster(data = NDVIbaltimorePLOT)+
  #scale_fill_gradient(low= "white",high = "black")+
  #raster
  ggnewscale::new_scale_fill()+
  geom_spatraster(data = NDVI_inside)+
  scale_fill_gradient(low = "white", high = "forestgreen", na.value = NA, name = "NDVI")+
  
  #polygons
  geom_sf(data = Minneapolis, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-93.35, -93.19), ylim = c(44.89, 45.06))+
  #title and save
  labs(title = "Map of Minneapolis Redlining Grades Compared to \nSatellite NDVI Greenery Data")

minneapolis_plot

ggsave(filename = "MinneapolisPLOT.png", 
       path = "PLOTS/", 
       width = 6, 
       height = 6, 
       dpi = 600)
```


```{r}
####Birmingham####
RED <- rast(x = "Data/Birmingham/T16SEC_20220427T162829_B04.jp2")
NIR <- rast(x = "Data/Birmingham/T16SEC_20220427T162829_B08.jp2")
NDVI <- (NIR - RED) / (NIR + RED)

#had to check a few things
#ext(NDVIplot)
#ext(asvect)


NDVIplot<- terra::project(x = NDVI, "EPSG:4326")
asvect <- as_spatvector(Birmingham)
NDVI_inside <- mask(NDVIplot,asvect)
NDVI_outside <- mask(NDVIplot,asvect, inverse=TRUE)

#ggplot()+
#  geom_spatraster(data = NDVI_inside)


birmingham_plot <- ggplot()+
  #BW raster
  geom_spatraster(data = NDVI_outside)+
  scale_fill_gradient(low="white", high = "grey", guide = "none")+

  #geom_spatraster(data = NDVIbaltimorePLOT)+
  #scale_fill_gradient(low= "white",high = "black")+
  #raster
  ggnewscale::new_scale_fill()+
  geom_spatraster(data = NDVI_inside)+
  scale_fill_gradient(low = "white", high = "forestgreen", na.value = NA, name = "NDVI")+
  
  #polygons
  geom_sf(data = Birmingham, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-86.95, -86.67), ylim = c(33.43, 33.64))+
  #title and save
  labs(title = "Map of Birmingham Redlining Grades Compared to \nSatellite NDVI Greenery Data")

birmingham_plot

ggsave(filename = "BirminghamPLOT.png", 
       path = "PLOTS/", 
       width = 6, 
       height = 6, 
       dpi = 600)
```

```{r}
####Phoenix####
RED <- rast(x = "Data/Phoenix/T12SUC_20211110T180601_B04.jp2")
NIR <- rast(x = "Data/Phoenix/T12SUC_20211110T180601_B08.jp2")
NDVI <- (NIR - RED) / (NIR + RED)

#had to check a few things
#ext(NDVIplot)
#ext(asvect)


NDVIplot<- terra::project(x = NDVI, "EPSG:4326")
asvect <- as_spatvector(Phoenix)
NDVI_inside <- mask(NDVIplot,asvect)
NDVI_outside <- mask(NDVIplot,asvect, inverse=TRUE)

#ggplot()+
#  geom_spatraster(data = NDVI_inside)


phoenix_plot <- ggplot()+
  #BW raster
  geom_spatraster(data = NDVI_outside)+
  scale_fill_gradient(low="white", high = "grey", guide = "none")+

  #geom_spatraster(data = NDVIbaltimorePLOT)+
  #scale_fill_gradient(low= "white",high = "black")+
  #raster
  ggnewscale::new_scale_fill()+
  geom_spatraster(data = NDVI_inside)+
  scale_fill_gradient(low = "white", high = "forestgreen", na.value = NA, name = "NDVI")+
  
  #polygons
  geom_sf(data = Phoenix, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-112.13, -112.02), ylim = c(33.42, 33.51))+
  #title and save
  labs(title = "Map of Phoenix Redlining Grades Compared to \nSatellite NDVI Greenery Data")

phoenix_plot

ggsave(filename = "PhoenixPLOT.png", 
       path = "PLOTS/", 
       width = 6, 
       height = 6, 
       dpi = 600)
```

```{r}
####Indianapolis####
RED <- rast(x = "Data/Indianapolis/T16TEK_20210726T162901_B04.jp2")
NIR <- rast(x = "Data/Indianapolis/T16TEK_20210726T162901_B08.jp2")
NDVI <- (NIR - RED) / (NIR + RED)

#had to check a few things
#ext(NDVIplot)
#ext(asvect)


NDVIplot<- terra::project(x = NDVI, "EPSG:4326")
asvect <- as_spatvector(Indianapolis)
NDVI_inside <- mask(NDVIplot,asvect)
NDVI_outside <- mask(NDVIplot,asvect, inverse=TRUE)

#ggplot()+
#  geom_spatraster(data = NDVI_inside)


plot <- ggplot()+
  #BW raster
  geom_spatraster(data = NDVI_outside)+
  scale_fill_gradient(low="white", high = "grey", guide = "none")+

  #geom_spatraster(data = NDVIbaltimorePLOT)+
  #scale_fill_gradient(low= "white",high = "black")+
  #raster
  ggnewscale::new_scale_fill()+
  geom_spatraster(data = NDVI_inside)+
  scale_fill_gradient(low = "white", high = "forestgreen", na.value = NA, name = "NDVI")+
  
  #polygons
  geom_sf(data = Indianapolis, aes(color = grade), fill = NA, linewidth  = 1)+
  scale_color_manual(values = color_grade_table$fill)+

  #zoom
  coord_sf(xlim = c(-86.3, -86), ylim = c(39.66, 39.93))+
  #title and save
  labs(title = "Map of Indianapolis Redlining Grades Compared to \nSatellite NDVI Greenery Data")

plot

ggsave(filename = "IndianapolisPLOT.png", 
       path = "PLOTS/", 
       width = 6, 
       height = 6, 
       dpi = 600)
```
### Q7 (2 points)
Now, let's examine the relationship between redlining and NDVI. Temporarily re-read in your redlining polygons using `terra:::vect()`. You can use `terra:extract()` on these temporary polygons within `mutate()` on your original polygons read in with `read_sf()`. Because the output of `terra::extract()` is a data.frame, `dplyr::pull()` can be helpful. 

Extract the mean, median, and central 95% quantile of NDVI from each delineated neighborhood while retaining the identity of the city. Perform your choice of at least two exploratory data visualizations utilizing different variables to evaluate this relationship and examine whether it differs between cities. 

### Bonus 1 (1 point)
Perform a statistical test to support your visual analysis above. 

### Q8 (2 points)
Create a final plot and describe whether NDVI is associated with historical redlining. Does this pattern differ between the five cities examined here? If so, how? 

### Bonus 2 (1 point)
Include the results of your statistical test in the final plot and use prose to incorporate statistical output in the context of the question above. 

